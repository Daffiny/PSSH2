#!/usr/bin/env perl
#
use Getopt::Long;
use strict;

my $usage="
NAME
  find_best_pdb_for_seqres_md5 - find a pdb code and chain that best represents the SEQRES sequence 
SYNOPSIS
  find_best_pdb_for_seqres_md5 <-m md5> 
DESCRIPTION
  find_best_pdb_for_seqres_md5 takes an input md5 and runs searches on the pdb tables in Aquaria
  selection criteria are:
  1. find a structure with as much overlap between SEQRES and coordinates as possible
  2. select an X-ray structure 
  2a. slect an X-ray structure with good resolution
  3. select a new structure  
  (by default we give only one structure)
OPTIONS
  -h          The option -h displays help and exits.
  -d          Debug option: be verbose (not implemented yet!)
  -m		  md5 sum of SEQRES sequence to search
  -n N		  return up to N pdb ids with longest overlap with SEQRES
AUTHOR
  Andrea Schafferhans <andrea.schafferhans\@rostlab.org>
\n";

# if there are no arguments or -h, then print man entry
if (@ARGV<1) {die ($usage);}
our($dbg,$help,$md5,$multi,$acceptRatio);
$help = 0;
$multi = 1;  # how many structure we return 
$acceptRatio=0.9; # how long the less long alignments can be compared to the longest
my $args_ok=GetOptions( 'debug'  => \$dbg,
                        'help' => \$help,
                        'md5=s' => \$md5,
                        'n=i' => \$multi 
);

if ($help || !$args_ok){
	print $usage;
	exit;
}


my @selectedIds;

#  1. find a structure with as much overlap between SEQRES and coordinates as possible
#  get all chains for the given md5
my $alignInfo = `DB.aquaria_local "select c.pdb_id, c.chain, c.Align_to_SEQRES from PDB_chain c where c.MD5_Hash='$md5';"`; 
#print $alignInfo;

my %aliLength;
my %pdbCode;
my %chain;
my %method;
my %resolution;
my %published;
my @alignLines = split /\n/, $alignInfo;
# first line has column headings
shift @alignLines;
# split out the info
foreach my $line(@alignLines){
    my @columns = split /\t/, $line;
#    print join('|', @columns), "\n";
    my $id = $columns[0];
    if ($columns[1]){$id .= '_'.$columns[1]};
    my @alignPieces = split /\\n/, $columns[2];
#    print join('||', @alignPieces), "\n";
    my $length = 0;
    foreach my $piece(@alignPieces){
	my ($seqres, $atom) = split /\:/, $piece;
	if ($seqres =~ /\-/){
	    my ($seqresStart, $seqresEnd) = split /\-/, $seqres;    
	    $length += ($seqresEnd-$seqresStart+1);
	}
	else {$length++}
#	print " at $seqres : aliLength: $aliLength \n"; 
    }
#    print "aliLength: $aliLength \n";
    $aliLength{$id} = $length;
    $pdbCode{$id} = $columns[0];
    $chain{$id} = $columns[1];
}

#print %aliLength, "\n";

# find longest alignment(s)
# accept everything that is at least x% of the longest alignment
my @sortedIds = sort sortByAliLength (keys %aliLength);
#print "sorted Ids: ", join (',', @sortedIds), "\n";
my $maxAliLength = $aliLength{$sortedIds[0]};
#print $maxAliLength, "\n";
my @bestIds;
BEST: foreach my $id(@sortedIds){
    if ($aliLength{$id} >= $maxAliLength*$acceptRatio){
		push @bestIds, $id;
    }
    else {last BEST};
}
#print "best Ids: ", join (',', @bestIds), "\n";

# if there is more than one with the longest alignment length
# take the next steps:
#  2. select an X-ray structure
#  2a. slect an X-ray structure with good resolution
#  3. select a new structure
if ($#bestIds > $multi-1){
    my @xray;
	# get the info from the database and parse
    foreach my $id(@bestIds){
		my $p = $pdbCode{$id};
#		my $c = $chain{$id}
		my $strucInfo = `DB.aquaria_local "select p.Published, p.Experimental_Method, p.Resolution from PDB p where p.PDB_ID='$p'";`; 
		my @strucLines = split /\n/, $strucInfo;
# first line has column headings
		my $line = $strucLines[1];
		my @columns = split /\t/, $line;
#	print join('|', @columns), "\n";
		$published{$id} = $columns[0];
		$method{$id} = $columns[1];
		$resolution{$id} = $columns[2];
		if ($method{$id} =~ /X-ray/){
	    	push @xray, $id;
		}
    }

    # evaluate the info
	# check there are any xray structures
    if ($xray[0]){
    	# if there is more than one xray structure we have to sort
		if ($#xray > 0){
			# sort by resolution
		    foreach my $id(@xray){
				my @sortedIds = sort sortByLengthAndResolution @xray;
				@selectedIds = @sortedIds;
	    	}
		}
		else {
#	    	$selectedId = $xray[0];
			push @selectedIds, $xray[0];
		}
    }
	# if we don't have xray, take the most recent structure
    else {
		foreach my $id(@bestIds){
	    	my @sortedIds = sort sortByPublished @bestIds;
		    @selectedIds = @sortedIds;
		}
    }
}
else {
    @selectedIds = @bestIds;
}

# work out the slice we want to return
my $lastIndex;
if ($#selectedIds > $multi-1){
	$lastIndex = $multi-1;
}
else {
	$lastIndex = $#selectedIds;
}

print join(";", @selectedIds[0 .. $lastIndex]), "\n";



sub sortByAliLength {
    $aliLength{$b} <=> $aliLength{$a};
}

sub sortByLengthAndResolution {
    $aliLength{$b} <=> $aliLength{$a} ||
    $resolution{$a} <=> $resolution{$b};
}

sub sortByPublished {
    $published{$b} <=> $published{$a};
}
