#!/bin/bash

if [ -z "$conf_file" ]; then
	conf_file='/etc/pssh2.conf'
fi

#### parameters (will be overwritten by anything read from conf file)
pdb_full_status_table="pdb_full_status"
pa3mfile='query.uniprot20.psipred.a3m' 
a3mfile='query.uniprot20.a3m' 
hmmfile='query.uniprot20.hhm'
a3mfile_gz=$a3mfile.gz
#pa3mfile_gz=$pa3mfile.gz
rootDir="/mnt/project/pssh/pssh2_project/" 
hhlib=$rootDir'hhsuite-2.0.13'
util_dir=$rootDir"src/util/"

# get configurable options, e.g. local file paths
if [ -s $conf_file ]
then
	source $conf_file
fi

usage()
{
cat << EOT
NAME
  build_hhblits_structure_profile - generate a hhblits aligment file (called a3m) for a pdb sequence
SYNOPSIS
  build_hhblits_structure_profile [-R|-F n] [-s] [-h] [-D]  <-m md5ToWorkOn> 
DESCRIPTION
  build_hhblits_profile takes an input sequence,
  calls build_hhblits_profile to scan agains uniprot20 and generate an a3m alignment, 
  then it  runs addss.pl on the a3m file (based on the best pdb structure for the sequence),
  producing a new a3m file including the secondary structure.
  Any input behind "--" is passed on build_hhblits_profile 
OPTIONS
  -h          The option -h displays help and exits.
  -D          Debug option: do not remove or zip output files
  -m 		  md5 number of sequence to work on
  -F n        Set force remaking status for making of HMM profile (run build_hhblits_profile):
     0           do not make profile unless none exists
     1           run only if the profile is older than the last update of uniprot20 (default)
     2           always run, even if the profile exists 
  -R          Retain (DO NOT remake) the HMM profile (same as -F 0)
  -s          Operate silently 
AUTHOR
  Andrea Schafferhans <andrea.schafferhans@rostlab.org>
EOT
exit 1
}


force=1
debug=0
passOpt=" " 
add=1
silent=0
while getopts :sDm:F:Rh opt
do
	case $opt in
	s) silent=1; debug=0; passOpt="$passOpt -$opt";;
	D) debug=1;; 
	m) md5=$OPTARG;;
	F) force=$OPTARG;;
	R) force=0;;
	h) usage; echo " "; build_hhblits_profile -h; exit;;
	:)  echo "Error: -$OPTARG requires an argument"; usage; exit 1;;
	esac
done

if [ $debug -eq 1 ]
then
	set -x
fi

shift $(expr $OPTIND - 1 )
passOpt="$passOpt $@"


export HHLIB=$hhlib

CC=`$util_dir/find_cache_path -m $md5`
input_seq_file=$CC/query.fasta

# check whether an input file already exists in $CC
get_seq=0
if [ -s $input_seq_file ] 
then
	old_md5=`cat $input_seq_file|fasta_to_md5`
	if  [ $old_md5 == $md5 ]
	then
		echo "working with old file $input_seq_file, with md5: $old_md5"
	else 
		get_seq=1
		echo "old file $input_seq_file, has different md5: $old_md5 -> retrieve again!"
	fi
else
	get_seq=1
fi

if [ $get_seq -eq 1 ]
then 
	temp_fasta_file=`get_fasta_for_md5 $md5`
	if [ -s $temp_fasta_file ]
	then	
		### create cachedir if not existent
		mkdir -p $CC
		if [ -d $CC ] 
		then
			cp $temp_fasta_file $input_seq_file
		else 
			echo "ERROR: was not able to work on cache for $CC please go fix"
		fi
	fi
fi

a3m_stamp=0
# now we should have input, check what needs to be done
if [ -s $input_seq_file ] 
then
	cd $path
	skip_build=0
	skip_add=0

	if [ $force -le 1 ] 
	then
	# check whether we already have a psipred a3m
		if [ -s $pa3mfile ] 
		then
			pa3m_stamp=`stat -c%Y $pa3mfile`
	   		if [ $force -eq 1 ] 
	    	then
				db_stamp=`DB.pssh2_local "select last_update_stamp from database_status where name='uniprot20' order by last_update_stamp" | tail -1`
				if [ $pa3m_stamp -gt $db_stamp ]
				then
		    		skip_add=1
		    		skip_build=1
			    fi
			else
				skip_add=1
		    	skip_build=1
			fi
    		if [ $silent -eq 0 ]
    		then
	    		echo "psipred_a3m already made: $pa3m_stamp in "
				pwd
				if [ $skip_add -eq 1 ] 
				then
					echo "file will be used again"
				else
					echo "file will be remade"
				fi
			fi
		elif [ -s $a3mfile_gz ]
		then
			a3m_stamp=`stat -c%Y $a3mfile_gz`
		elif [ -s $a3mfile ]
		then
			a3m_stamp=`stat -c%Y $a3mfile`
		fi
		if [ a3m_stamp -gt 0 ]
		then
			if [ $force -eq 1 ] 
		    then
				db_stamp=`DB.pssh2_local "select last_update_stamp from database_status where name='uniprot20' order by last_update_stamp" | tail -1`
				if [ $a3m_stamp -gt $db_stamp ]
				then
			    	skip_build=1
			    fi
			else
			    skip_build=1
			fi
 		   	if [ $silent -eq 0 ]
    		then
	    		echo "a3m already made: $a3m_stamp in "
				pwd
				if [ $skip_build -eq 1 ] 
				then
					echo "file will be used again"
				else
					echo "file will be remade"
				fi
			fi
		fi
	fi
else
	# if there is no input, we exit now with an error
	s=`date +%s`
	DB.pssh2_local "insert into pssh2_local.$pdb_full_status_table set md5=\"$md5\" , count=-99 , stamp=$s , runtime=0" 
	echo "ERROR: could not find sequence: $input_seq_file or $temp_fasta_file"
	exit
fi

cd $CC
if [ $skip_build -eq 0 ]
then
	time nice build_hhblits_profile -f  query.fasta -m  $hmmfile -a $a3mfile -r query.uniprot20.hhr $passOpt
else
	gunzip $a3mfile_gz
	if [ $silent -eq 0 ]
 	then
		echo "skip making A3M."
	fi	
fi

# Note that the hhsuite installed on the cluster is not customised to our local Rostlab setup
# /usr/share/hhsuite/scripts/HHPaths.pm needs to be adjusted!


if [ $skip_add -eq 0 ]
then
	if [ -s $a3mfile ] 
	then
		# before giving the a3m with the md5 sum as input to addss.pl, we have to replace the id for the found pdb_id
		a3mfile_pdb=$a3mfile.pdbid.a3m
		pa3mfile_pdb=$pa3mfile.pdbid.a3m
		md5=`cat query.fasta|fasta_to_md5`
		pdb_id=`find_best_pdb_for_seqres_md5 -m $md5`
		sed 's/$md5/$pdb_id/g' < $a3mfile > $a3mfile_pdb
		$HHLIB/scripts/addss.pl $a3mfile_pdb $pa3mfile_pdb
		# remove the pdb id from the $pa3mfile_pdb 
		sed 's/$pdb_id/$md5/g' < $pa3mfile_pdb > $pa3mfile
		# clean up
		rm $pa3mfile_pdb $a3mfile_pdb
		gzip $a3mfile
	else
		fail=-1
	fi
fi

count=0
if [ -s $pa3mfile ]
then
	count=`grep -c "^>" $pa3mfile"
else
	if [ $fail eq 0 ]
		fail=-2
	fi
	count=$fail
fi

DB.pssh2_local "insert into pssh2_local.$status_table set md5=\"$md5\" , count=$count , stamp=$s , runtime=0 ON DUPLICATE KEY UPDATE count=$n , stamp=$s , runtime=$runtime " 
